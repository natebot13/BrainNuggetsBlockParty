#pragma config(Hubs,  S4, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S2,     compass,        sensorI2CHiTechnicCompass)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S4_C1_1,     xset1,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C1_2,     xset2,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C2_1,     yset1,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C2_2,     yset2,         tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S4_C3_1,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S4_C3_2,    servo2,               tServoContinuousRotation)
#pragma config(Servo,  srvo_S4_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S4_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S4_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S4_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c";
#include "MotorToServo.c";
#include "PolarDrive.c";

task main()
{
	short offset = 0;
	int x = 0;
	int y = 0;
	int motorsx = 0;
	int motorsy = 0;
	int adjx1 = 0;
	int adjy1 = 0;
	int adjx2 = 0;
	int adjy2 = 0;
	int joyangle = 0;
	int joyhyp = 0;
	int robangle = 0;
	int finalangle = 0;
	float turnval = 0;

	TFileHandle FILE;
	TFileIOResult IOResult;
	string fileName = "Offset.txt";
	int size = 0;

	OpenRead(FILE, IOResult, fileName, size);
	ReadShort(FILE, IOResult, offset);
	Close(FILE, IOResult);

	servo[servo1] = 0;

	waitForStart();
	while(true){
		//get the state of the joysticks
		getJoystickSettings(joystick);
		x = joystick.joy1_x1;
		y = joystick.joy1_y1;
		turnval = joystick.joy1_x2;
		turnval = turnval*0.787401;

		//take a compass sensor reading
		robangle = SensorValue[compass];

		//robangle = nMotorEncoder[motorA];
		joyangle = radiansToDegrees(atan2(y,x));

		//find magnitude of joystick position
		joyhyp = sqrt((y*y)+(x*x));

		//set the final angle at which the robot will travel based on the robot's
		//actual orientation, joystick angle, and the offset value set earlier
		finalangle = joyangle + robangle + offset;

		//find the values for the diagonal motor pairs based on the final angle and magnitude of the joystick
		motorsx = cosDegrees(finalangle)*joyhyp;
		motorsy = sinDegrees(finalangle)*joyhyp;

		//draw some debug output on the screen
		nxtDisplayTextLine(0,"Offset: %d",offset);
		nxtDisplayTextLine(1,"robangle: %d",robangle);
		nxtDisplayTextLine(2,"X: %d",motorsx);
		nxtDisplayTextLine(3,"Y: %d",motorsy);
		nxtDrawLine(30,50,motorsx,motorsy);

		//set the
		adjx1 = motorsx +(-turnval);
		adjy1 = motorsy + turnval;
		adjx2 = motorsx + turnval;
		adjy2 = motorsy + (-turnval);

		if (abs(adjx1) < 10){adjx1 = 0;}
		if (abs(adjy1) < 10){adjy1 = 0;}
		if (abs(adjx2) < 10){adjx2 = 0;}
		if (abs(adjy2) < 10){adjy2 = 0;}
		//set motors to final values
		motor[xset1] = adjx1;
		motor[yset1] = adjy1;
		motor[xset2] = adjx2;
		motor[yset2] = adjy2;
//control spinner servo w/ face buttons
		if (joy1Btn(8) == 1) {servo[servo1] = 50;}
		else {servo[servo1] = 0;}
	}
	nxtDisplayTextLine(5,"Servo: %d", servo[servo2]);
	servo[servo2] = joy1Btn(5)*180 + joy1Btn(7)*(-180);

}
